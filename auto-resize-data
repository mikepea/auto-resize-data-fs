#!/usr/bin/env python

# check for sd[b-z]
# check for vg_data
# check sizes and names of PVs in vg_data, compare to /proc/partitions

# read /proc/partitions

import re
import subprocess

def get_valid_disks(matcher_re, blacklist):
  valid_disks = []
  partitions_file = '/proc/partitions'
  partitions = open(partitions_file, 'r').readlines()
  for partition_line in partitions:
    line = partition_line.rstrip()
    if matcher_re.match(line):
      part_info = line.split()
      valid_disks.append(part_info[3])
  return valid_disks

def full_device_path(device):
  if re.match('^/dev/', device):
    return device
  else:
    return "/dev/" + device

def is_pv_enabled_on_device(device):
  full_device = full_device_path(device)
  pvck_output = subprocess.check_output(
      ['sudo', 'pvck', full_device],
      stderr=subprocess.STDOUT
      )
  if re.search('Could not find LVM label', pvck_output):
    return False
  elif re.search('Found label on', pvck_output):
    return True
  else:
    raise RuntimeError("Unexpected output received from pvck: {}".format(pvck_output))

def does_vg_exist(vg_name):
  full_device = full_device_path(vg_name)
  vgck_ret = subprocess.call(['sudo', 'vgck', full_device])
  if vgck_ret == 5:
    # not present
    return False
  elif vgck_ret == 0:
    # all good
    return True
  else:
    raise RuntimeError("Unexpected return code received from vgck: {}".format(vgck_ret))

def is_pv_in_vg(vg_name, pv):
  full_pv = full_device_path(pv)
  pvdisplay_out = subprocess.check_output(['sudo', 'pvdisplay', full_pv])
  if re.search('^\s+VG Name\s+{}'.format(vg_name), pvdisplay_out, re.MULTILINE):
    return True
  elif re.search('^\s+VG Name\s*$', pvdisplay_out, re.MULTILINE) :
    return False
  else:
    m = re.search('^\s+VG Name\s+(.+)\s*$', pvdisplay_out, re.MULTILINE)
    if m != None:
      raise RuntimeError("PV {} is not in VG {} - it is already in VG {}.".format(full_pv, vg_name, m.group(1)))
    else:
      raise RuntimeError("Unexpected output from pvdisplay when checking for {} in {}".format(vg_name, pvdisplay_out))

def pvcreate(device):
  full_device = full_device_path(device)
  ret = subprocess.call(['sudo', 'pvcreate', full_device])
  if ret != 0:
    raise RuntimeError("Failed to pvcreate {}".format(full_device))

def vgcreate(vg_name, pvs):
  full_pv_list = map(full_device_path, pvs)
  args = list(itertools.chain.from_iterable([ 'sudo', 'vgcreate', full_pv_list])) # flatten
  ret = subprocess.call(args)
  if ret != 0:
    raise RuntimeError("Failed to vgcreate {} containing {}".format(vg_name, pvs))

def vgextend_with_new_pvs(vg_name, pvs):
  for pv in pvs:
    if not is_pv_in_vg(vg_name, pv):
      print "Extending VG {} with {}".format(vg_name, full_device_path(pv))
      vgextend(vg_name, pv)

def vgextend(vg_name, pv):
  full_device = full_device_path(pv)
  ret = subprocess.call(['sudo', 'vgextend', vg_name, full_device])
  if ret != 0:
    raise RuntimeError("Failed to vgextend {} with {}".format(vg_name, full_device))

#-----------------------------------------------------------------------

if __name__ == '__main__':

  # variables that we could concievably treat as config
  matching_disks_re = re.compile('.+\ssd[b-z]$')
  blacklist_disks = []
  vg_name = "vg_data"
  lv_name = "lv_data"

  # Get a list of available disks, pvcreate them if they are not already PVs
  disks = get_valid_disks(matching_disks_re, blacklist_disks)
  for device in disks:
    if is_pv_enabled_on_device(device):
      print "PV is enabled on {}".format(device)
    else:
      print "PV is not enabled on {}".format(device)
      pvcreate(device)
      if not is_pv_enabled_on_device(device):
        raise RuntimeError("Could not pvcreate {}".format(device))

  # Either create or extend the VG
  if does_vg_exist(vg_name):
    vgextend_with_new_pvs(vg_name, disks) # is idempotent, so won't do anything if pvs are already in vg
  else:
    print "VG {} does not exist. Creating containing {}.".format(vg_name, disks)
    vgcreate(vg_name, disks)

